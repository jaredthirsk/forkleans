@namespace Shooter.Client.Components
@using Shooter.Shared.Models
@implements IDisposable
@inject IJSRuntime JS
@inject ILogger<GameCanvas> Logger

<div class="game-canvas-container">
    <div class="canvas-wrapper">
        <canvas @ref="canvasElementA" width="@Width" height="@Height" class="game-canvas"></canvas>
        <canvas @ref="canvasElementB" width="@Width" height="@Height" class="game-canvas" style="display: none;"></canvas>
        <canvas @ref="canvasElementC" width="@Width" height="@Height" class="game-canvas" style="display: none;"></canvas>
        <div class="game-info">
            <div class="zone-info">Current Zone: @currentZone</div>
            <div class="server-info">Server: @currentServer</div>
            <div class="player-info">Player: @playerDebugInfo</div>
        </div>
    </div>
</div>

<style>
    .game-canvas-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #1a1a1a;
        padding: 20px;
        position: relative;
    }
    
    .canvas-wrapper {
        position: relative;
        width: @(Width + 4)px;  /* Account for border */
        height: @(Height + 4)px;  /* Account for border */
    }
    
    .game-canvas {
        border: 2px solid #444;
        background-color: #000;
        position: absolute;
        top: 0;
        left: 0;
    }
    
    .game-info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-family: monospace;
        font-size: 14px;
        background: rgba(0, 0, 0, 0.7);
        padding: 10px;
        border-radius: 5px;
        z-index: 10;
    }
    
    .zone-info {
        color: #88ff88;
        margin-bottom: 5px;
    }
    
    .server-info {
        color: #8888ff;
    }
</style>

@code {
    [Parameter] public int Width { get; set; } = 800;
    [Parameter] public int Height { get; set; } = 600;
    [Parameter] public WorldState? WorldState { get; set; }
    [Parameter] public string? PlayerId { get; set; }
    [Parameter] public string? ServerId { get; set; }
    [Parameter] public List<GridSquare>? AvailableZones { get; set; }
    [Parameter] public EventCallback<(float x, float y)> OnMouseClick { get; set; }
    [Parameter] public EventCallback<(float x, float y)> OnMouseRightClick { get; set; }
    [Parameter] public EventCallback OnMouseRelease { get; set; }
    
    private ElementReference canvasElementA;
    private ElementReference canvasElementB;
    private ElementReference canvasElementC;
    private IJSObjectReference? canvasContext;
    private System.Timers.Timer? renderTimer;
    private string currentZone = "Unknown";
    private string currentServer = "Unknown";
    private string playerDebugInfo = "Not found";
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                var module = await JS.InvokeAsync<IJSObjectReference>("import", "./js/gameCanvas.js");
                canvasContext = await module.InvokeAsync<IJSObjectReference>("initTripleCanvas", canvasElementA, canvasElementB, canvasElementC, DotNetObjectReference.Create(this));
                
                renderTimer = new System.Timers.Timer(33); // ~30 FPS
                renderTimer.Elapsed += async (s, e) => await RenderFrame();
                renderTimer.Start();
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Failed to initialize game canvas");
            }
        }
    }
    
    private async Task RenderFrame()
    {
        if (canvasContext != null && WorldState != null)
        {
            // Start a new frame
            await canvasContext.InvokeVoidAsync("beginFrame");
            
            // Find player position for camera centering
            var player = WorldState.Entities.FirstOrDefault(e => e.EntityId == PlayerId);
            var cameraPos = player?.Position ?? Vector2.Zero;
            var cameraOffset = new { x = cameraPos.X - Width / 2, y = cameraPos.Y - Height / 2 };
            
            // Clear canvas with camera offset
            await canvasContext.InvokeVoidAsync("clearCanvas", Width, Height, cameraOffset);
            
            // Draw zone boundaries with available zones
            var availableZonesArray = AvailableZones?.Select(z => new { x = z.X, y = z.Y }).ToArray() ?? Array.Empty<object>();
            await canvasContext.InvokeVoidAsync("drawZoneBoundaries", Width, Height, cameraOffset, availableZonesArray);
            
            // Sort entities for proper layering (bullets on top, explosions last)
            var sortedEntities = WorldState.Entities
                .OrderBy(e => e.Type == EntityType.Explosion ? 1 : 0)
                .ThenBy(e => e.Type == EntityType.Bullet ? 1 : 0);
            
            foreach (var entity in sortedEntities)
            {
                var screenPos = WorldToScreen(entity.Position, cameraPos);
                
                // Skip entities outside screen
                if (screenPos.X < -50 || screenPos.X > Width + 50 || 
                    screenPos.Y < -50 || screenPos.Y > Height + 50)
                    continue;
                
                var color = GetEntityColor(entity);
                var size = GetEntitySize(entity);
                
                await canvasContext.InvokeVoidAsync("drawEntity", 
                    screenPos.X, screenPos.Y, size, color, entity.Rotation,
                    entity.Type.ToString(), entity.SubType, entity.State.ToString(), entity.StateTimer);
                    
                // Draw health bar for living entities
                if (entity.Type != EntityType.Bullet && entity.Type != EntityType.Explosion && 
                    entity.State == EntityStateType.Active && entity.Health > 0)
                {
                    var maxHealth = entity.Type == EntityType.Player ? 1000f : 
                                   entity.SubType == (int)EnemySubType.Kamikaze ? 30f : 50f;
                    await canvasContext.InvokeVoidAsync("drawHealthBar",
                        screenPos.X, screenPos.Y - size - 10, size * 2, entity.Health / maxHealth);
                }
            }
            
            // Draw death message if player is dead
            if (player != null && (player.State == EntityStateType.Dead || player.State == EntityStateType.Dying))
            {
                var respawnTimer = 5f - player.StateTimer;
                if (respawnTimer > 0)
                {
                    await canvasContext.InvokeVoidAsync("drawDeathMessage", Width, Height, respawnTimer);
                }
            }
            
            // End frame and flip buffers
            await canvasContext.InvokeVoidAsync("endFrame");
            
            // Update zone info
            if (player != null)
            {
                var zone = GridSquare.FromPosition(player.Position);
                currentZone = $"{zone.X}, {zone.Y}";
                currentServer = ServerId ?? "Unknown";
                playerDebugInfo = $"Pos: ({player.Position.X:F0}, {player.Position.Y:F0}) State: {player.State}";
            }
            else
            {
                // More detailed debug info when player not found
                var playerCount = WorldState.Entities.Count(e => e.Type == EntityType.Player);
                var totalEntities = WorldState.Entities.Count;
                playerDebugInfo = $"Not found - PlayerId: {PlayerId ?? "null"}, Players: {playerCount}, Total: {totalEntities}";
                
                // Log for debugging
                if (!string.IsNullOrEmpty(PlayerId))
                {
                    Logger.LogWarning("Player {PlayerId} not found in world state. Total entities: {Count}", PlayerId, totalEntities);
                }
            }
            await InvokeAsync(StateHasChanged);
        }
    }
    
    private Vector2 WorldToScreen(Vector2 worldPos, Vector2 cameraPos)
    {
        return new Vector2(
            Width / 2 + (worldPos.X - cameraPos.X),
            Height / 2 + (worldPos.Y - cameraPos.Y)
        );
    }
    
    private string GetEntityColor(EntityState entity)
    {
        if (entity.Type == EntityType.Player)
        {
            return entity.EntityId == PlayerId ? "#00ff00" : "#00aa00";
        }
        
        return entity.Type switch
        {
            EntityType.Enemy => entity.SubType switch
            {
                (int)EnemySubType.Kamikaze => "#ff4444",
                (int)EnemySubType.Sniper => "#44ff44",
                (int)EnemySubType.Strafing => "#ffaa44",
                _ => "#ff0000"
            },
            EntityType.Bullet => "#ffff00",
            EntityType.Explosion => "#ff8800",
            _ => "#ffffff"
        };
    }
    
    private int GetEntitySize(EntityState entity) => entity.Type switch
    {
        EntityType.Player => 15,
        EntityType.Enemy => entity.SubType == (int)EnemySubType.Kamikaze ? 10 : 12,
        EntityType.Bullet => 3,
        EntityType.Explosion => entity.SubType == 1 ? 15 : 25,
        _ => 10
    };
    
    [JSInvokable]
    public async Task OnLeftClick(float x, float y)
    {
        Logger.LogDebug("Left click at {X}, {Y}", x, y);
        await OnMouseClick.InvokeAsync((x, y));
    }
    
    [JSInvokable]
    public async Task OnRightClick(float x, float y)
    {
        Logger.LogDebug("Right click at {X}, {Y}", x, y);
        await OnMouseRightClick.InvokeAsync((x, y));
    }
    
    [JSInvokable]
    public async Task OnLeftRelease()
    {
        Logger.LogDebug("Left button released");
        await OnMouseRelease.InvokeAsync();
    }
    
    public void Dispose()
    {
        renderTimer?.Stop();
        renderTimer?.Dispose();
        _ = canvasContext?.DisposeAsync();
    }
}