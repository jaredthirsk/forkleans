@using Microsoft.JSInterop
@using Shooter.Client.Common
@using Shooter.Shared.Models
@using Shooter.Shared.Movement
@inject IJSRuntime JS
@inject GranvilleRpcGameClientService RpcGameClient
@inject NavigationManager Navigation
@inject ILogger<GamePhaser> Logger
@inject IHttpClientFactory HttpClientFactory
@inject IConfiguration Configuration
@implements IDisposable

<div class="phaser-game-container">
    <div id="phaser-container" class="phaser-viewport"></div>
    
    <StatusBar WarningMessage="@_warningMessage" />
    
    <div class="chat-container mt-3">
        <div class="chat-history" @ref="_chatHistoryElement">
            @foreach (var message in _chatMessages)
            {
                <div class="chat-message" style="color: @message.Color">
                    <span class="timestamp">[(@message.Timestamp.ToString("HH:mm:ss"))]</span>
                    <span class="sender">@message.Sender:</span>
                    <span class="text">@message.Text</span>
                </div>
            }
            <div @ref="_chatScrollAnchor"></div>
        </div>
        <div class="chat-input">
            <form @onsubmit="SendChatMessage" @onsubmit:preventDefault="true">
                <div class="input-group">
                    <input type="text" class="form-control" @bind="_chatInput" @bind:event="oninput" 
                           placeholder="Type a message..." maxlength="200" />
                    <button class="btn btn-primary" type="submit" disabled="@(string.IsNullOrWhiteSpace(_chatInput))">
                        Send
                    </button>
                </div>
            </form>
        </div>
        
        <div class="compact-controls mt-2" style="display: flex; align-items: center; gap: 20px;">
            <div class="control-item" style="display: flex; align-items: center; gap: 5px;">
                <span style="color: #888; font-size: 14px;">Bots:</span>
                <button class="compact-btn remove-btn" @onclick="RemoveBot" disabled="@_isProcessing" 
                        style="background: transparent; border: none; color: #888; font-size: 18px; width: 24px; height: 24px; padding: 0; cursor: pointer; border-radius: 4px; transition: all 0.2s ease; @(_isProcessing ? "opacity: 0.5; cursor: not-allowed;" : "")"
                        onmouseover="this.style.backgroundColor='#f44336'; this.style.color='white';"
                        onmouseout="this.style.backgroundColor='transparent'; this.style.color='#888';">
                    −
                </button>
                <span class="count-display" style="min-width: 40px; text-align: center; font-size: 14px; color: #e0e0e0;">
                    @_desiredBotCount
                    @if (_actualBotCount != _desiredBotCount)
                    {
                        <span style="color: #aaa;">(@_actualBotCount)</span>
                    }
                </span>
                <button class="compact-btn add-btn" @onclick="AddBot" disabled="@_isProcessing"
                        style="background: transparent; border: none; color: #888; font-size: 18px; width: 24px; height: 24px; padding: 0; cursor: pointer; border-radius: 4px; transition: all 0.2s ease; @(_isProcessing ? "opacity: 0.5; cursor: not-allowed;" : "")"
                        onmouseover="this.style.backgroundColor='#4CAF50'; this.style.color='white';"
                        onmouseout="this.style.backgroundColor='transparent'; this.style.color='#888';">
                    +
                </button>
            </div>
            
            <div class="control-item" style="display: flex; align-items: center; gap: 5px;">
                <span style="color: #888; font-size: 14px;">Zones:</span>
                <button class="compact-btn remove-btn" @onclick="RemoveZone" disabled="@_isProcessing"
                        style="background: transparent; border: none; color: #888; font-size: 18px; width: 24px; height: 24px; padding: 0; cursor: pointer; border-radius: 4px; transition: all 0.2s ease; @(_isProcessing ? "opacity: 0.5; cursor: not-allowed;" : "")"
                        onmouseover="this.style.backgroundColor='#f44336'; this.style.color='white';"
                        onmouseout="this.style.backgroundColor='transparent'; this.style.color='#888';">
                    −
                </button>
                <span class="count-display" style="min-width: 40px; text-align: center; font-size: 14px; color: #e0e0e0;">
                    @_desiredZoneCount
                    @if (_actualZoneCount != _desiredZoneCount)
                    {
                        <span style="color: #aaa;">(@_actualZoneCount)</span>
                    }
                </span>
                <button class="compact-btn add-btn" @onclick="AddZone" disabled="@_isProcessing"
                        style="background: transparent; border: none; color: #888; font-size: 18px; width: 24px; height: 24px; padding: 0; cursor: pointer; border-radius: 4px; transition: all 0.2s ease; @(_isProcessing ? "opacity: 0.5; cursor: not-allowed;" : "")"
                        onmouseover="this.style.backgroundColor='#4CAF50'; this.style.color='white';"
                        onmouseout="this.style.backgroundColor='transparent'; this.style.color='#888';">
                    +
                </button>
            </div>
            
        </div>
    </div>
    
    <div class="game-info mt-3" style="width: 800px; margin: 0 auto;">
        <div class="d-flex align-items-center">
            <span style="color: #888;">Controls</span>
            <span class="ms-2" style="cursor: help;" title="Movement: WASD + Numbers 0-9 for speed&#10;Right Click: Set heading direction&#10;Left Click: Shoot&#10;V: Toggle automove&#10;T: Toggle test mode&#10;Space: Auto shoot (when enabled)">
                <svg width="16" height="16" fill="currentColor" style="color: #888;">
                    <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1" fill="none"/>
                    <text x="8" y="12" text-anchor="middle" font-size="12" font-weight="bold">i</text>
                </svg>
            </span>
            <span class="ms-4" style="color: #888;">
                <span @onclick="ToggleAutoMove" style="cursor: pointer; user-select: none;">
                    Automove: <strong>@(_isAutoMoveEnabled ? "ON" : "OFF")</strong>
                </span>
                <span class="ms-3">|</span>
                <span class="ms-3" @onclick="ToggleAutoShoot" style="cursor: pointer; user-select: none;">
                    Auto shoot: <strong>@(_isAutoShootEnabled ? "ON" : "OFF")</strong>
                </span>
                <span class="ms-3">|</span>
                <span class="ms-3" @onclick="ToggleTestMode" style="cursor: pointer; user-select: none;" 
                      title="In test mode, bots move slowly and predictably for easier testing">
                    Test mode: <strong>@(_isTestMode ? "ON" : "OFF")</strong>
                </span>
            </span>
        </div>
        @if (!string.IsNullOrEmpty(_error))
        {
            <div class="alert alert-danger mt-2">@_error</div>
        }
    </div>
</div>

@code {
    private DotNetObjectReference<GamePhaser>? _dotNetRef;
    private string? _error;
    private string? _warningMessage;
    private bool _isInitialized = false;
    private System.Timers.Timer? _updateTimer;
    private Dictionary<string, GridSquare> _serverZoneMap = new();
    private CancellationTokenSource _disposeCts = new();
    private AutoMoveController? _autoMoveController;
    private bool _isAutoMoveEnabled = false;
    private bool _isAutoShootEnabled = false;
    private bool _isTestMode = false;
    private bool _victoryPauseActive = false;
    private System.Timers.Timer? _autoMoveTimer;
    private System.Timers.Timer? _statsUpdateTimer;
    private System.Timers.Timer? _warningClearTimer;
    private WorldState? _lastWorldState;
    private List<GridSquare> _availableZones = new();
    private bool _isProcessing = false;
    
    // Control counts
    private int _desiredBotCount = 0;
    private int _actualBotCount = 0;
    private int _desiredZoneCount = 4;
    private int _actualZoneCount = 0;
    
    // Chat related fields
    private List<ChatDisplayMessage> _chatMessages = new();
    private string _chatInput = "";
    private ElementReference _chatScrollAnchor;
    private ElementReference _chatHistoryElement;
    
    private class ChatDisplayMessage
    {
        public DateTime Timestamp { get; set; } = DateTime.Now;
        public string Sender { get; set; } = "";
        public string Text { get; set; } = "";
        public string Color { get; set; } = "#000000";
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            try
            {
                // Load saved settings from localStorage
                await LoadSettings();
                
                // Get player ID from RPC client
                var playerId = RpcGameClient.PlayerId;
                Logger.LogInformation("[PHASER_INIT] RpcGameClient instance {InstanceId} - PlayerId: {PlayerId}", 
                    RpcGameClient.GetHashCode(), playerId);
                    
                if (string.IsNullOrEmpty(playerId))
                {
                    Logger.LogError("No player ID available from RPC client");
                    Navigation.NavigateTo("/");
                    return;
                }

                // Create DotNet reference
                _dotNetRef = DotNetObjectReference.Create(this);

                // Initialize Phaser
                await JS.InvokeVoidAsync("gamePhaser.init", _dotNetRef, "phaser-container", playerId);
                
                // Subscribe to game events
                RpcGameClient.WorldStateUpdated += OnWorldStateUpdated;
                RpcGameClient.AvailableZonesUpdated += OnAvailableZonesUpdated;
                RpcGameClient.PreEstablishedConnectionsUpdated += OnPreEstablishedConnectionsUpdated;
                RpcGameClient.VictoryPauseReceived += OnVictoryPauseReceived;
                RpcGameClient.GameOverReceived += OnGameOverReceived;
                RpcGameClient.GameRestartedReceived += OnGameRestartedReceived;
                RpcGameClient.OneWayBoundaryStateChanged += OnOneWayBoundaryStateChanged;
                RpcGameClient.ChatMessageReceived += OnChatMessageReceived;
                
                // Add initial system message
                AddSystemMessage("Connected to game server");
                
                // Create automove controller
                _autoMoveController = new AutoMoveController(Logger, playerId, _isTestMode);
                
                // Start auto features timer (automove and autoshoot)
                _autoMoveTimer = new System.Timers.Timer(100); // 100ms update rate
                _autoMoveTimer.Elapsed += (sender, e) => 
                {
                    try 
                    {
                        if (!_disposeCts.Token.IsCancellationRequested)
                        {
                            UpdateAutoFeatures();
                        }
                    }
                    catch (ObjectDisposedException)
                    {
                        // CancellationTokenSource was disposed during component disposal
                    }
                };
                _autoMoveTimer.Start();
                
                _isInitialized = true;
                
                // Fetch server zone mappings
                await FetchServerZoneMappings();
                
                // Start update timer for server info
                _updateTimer = new System.Timers.Timer(1000);
                _updateTimer.Elapsed += async (sender, e) => 
                {
                    try 
                    {
                        await UpdateServerInfo();
                    }
                    catch (ObjectDisposedException)
                    {
                        // CancellationTokenSource was disposed during component disposal
                    }
                };
                _updateTimer.Start();
                
                // Start stats update timer
                _statsUpdateTimer = new System.Timers.Timer(2000); // Update every 2 seconds
                _statsUpdateTimer.Elapsed += async (sender, e) => 
                {
                    try 
                    {
                        await UpdateStats();
                    }
                    catch (ObjectDisposedException)
                    {
                        // CancellationTokenSource was disposed during component disposal
                    }
                };
                _statsUpdateTimer.Start();
            }
            catch (Exception ex)
            {
                _error = $"Failed to initialize game: {ex.Message}";
                Logger.LogError(ex, "Failed to initialize Phaser game");
            }
        }
    }

    private void OnWorldStateUpdated(WorldState worldState)
    {
        _lastWorldState = worldState;
        
        if (_isInitialized)
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    await JS.InvokeVoidAsync("gamePhaser.updateWorldState", worldState);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to update world state");
                }
            });
        }
    }

    private void OnAvailableZonesUpdated(List<GridSquare> zones)
    {
        _availableZones = zones;
        
        if (_isInitialized)
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    await JS.InvokeVoidAsync("gamePhaser.updateZoneInfo", zones);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to update zone info");
                }
            });
        }
    }

    private void OnPreEstablishedConnectionsUpdated(Dictionary<string, (bool isConnected, bool isNeighbor, bool isConnecting)> connections)
    {
        if (_isInitialized)
        {
            _ = InvokeAsync(async () =>
            {
                try
                {
                    // Convert to a format that can be serialized to JavaScript
                    var jsConnections = connections.ToDictionary(
                        kvp => kvp.Key,
                        kvp => new { 
                            isConnected = kvp.Value.isConnected, 
                            isNeighbor = kvp.Value.isNeighbor,
                            isConnecting = kvp.Value.isConnecting
                        }
                    );
                    await JS.InvokeVoidAsync("gamePhaser.updatePreEstablishedConnections", jsConnections);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to update pre-established connections");
                }
            });
        }
    }

    private async Task UpdateServerInfo()
    {
        if (_isInitialized)
        {
            await InvokeAsync(async () =>
            {
                try
                {
                    // Get server zone from parent component if available
                    var serverZone = GetServerZone();
                    await JS.InvokeVoidAsync("gamePhaser.updateServerInfo", RpcGameClient.CurrentServerId, serverZone);
                }
                catch { }
            });
        }
    }
    
    private async Task UpdateStats()
    {
        if (!_isInitialized || _disposeCts.Token.IsCancellationRequested) return;
        
        try
        {
            var siloUrl = Configuration["SiloUrl"] ?? "https://localhost:7071/";
            if (!siloUrl.EndsWith("/")) siloUrl += "/";
            
            // Update zone count
            using var httpClient = HttpClientFactory.CreateClient();
            var zonesResponse = await httpClient.GetFromJsonAsync<List<WorldZoneStats>>($"{siloUrl}api/world/zone-stats", _disposeCts.Token);
            if (zonesResponse != null)
            {
                _actualZoneCount = zonesResponse.Count;
            }
            
            // Update bot count by counting bot entities in all zones
            if (zonesResponse != null)
            {
                _actualBotCount = zonesResponse.Sum(z => z.PlayerCount); // This includes bots
                // TODO: We need a better way to distinguish bots from players
            }
            
            
            if (!_disposeCts.Token.IsCancellationRequested)
            {
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
            // Component is being disposed, ignore
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update stats");
        }
    }

    [JSInvokable]
    public void OnMovementInput(float x, float y)
    {
        try
        {
            // Block input during victory pause
            if (_victoryPauseActive)
            {
                Logger.LogDebug("Movement input blocked - Victory pause active");
                return;
            }
            
            var moveDir = new Vector2(x, y).Length() > 0 ? new Vector2(x, y) : (Vector2?)null;
            RpcGameClient.SendPlayerInputEx(moveDir, null);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to send movement input");
        }
    }

    [JSInvokable]
    public void OnShootInput(float x, float y)
    {
        try
        {
            // Block input during victory pause
            if (_victoryPauseActive)
            {
                Logger.LogDebug("Shoot input blocked - Victory pause active");
                return;
            }
            
            RpcGameClient.SendPlayerInputEx(null, new Vector2(x, y));
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to send shoot input");
        }
    }
    
    [JSInvokable]
    public void OnZoneMismatch(float playerX, float playerY, int playerZoneX, int playerZoneY, int serverZoneX, int serverZoneY)
    {
        Logger.LogWarning("[ZONE_MISMATCH] Player at position ({PlayerX:F1}, {PlayerY:F1}) is in zone ({PlayerZoneX}, {PlayerZoneY}) but server thinks they should be in zone ({ServerZoneX}, {ServerZoneY})",
            playerX, playerY, playerZoneX, playerZoneY, serverZoneX, serverZoneY);
        
        var isTransitioning = RpcGameClient.IsTransitioning;
        var warningText = $"Player in zone ({playerZoneX},{playerZoneY}) but connected to server for zone ({serverZoneX},{serverZoneY})";
        
        if (isTransitioning)
        {
            warningText += " - Transitioning...";
        }
        
        _warningMessage = warningText;
        InvokeAsync(StateHasChanged);
        
        // Clear the warning after 15 seconds (longer for debugging)
        _warningClearTimer?.Stop();
        _warningClearTimer?.Dispose();
        _warningClearTimer = new System.Timers.Timer(15000); // 15 seconds
        _warningClearTimer.Elapsed += (sender, e) =>
        {
            _warningMessage = null;
            InvokeAsync(StateHasChanged);
            _warningClearTimer?.Dispose();
            _warningClearTimer = null;
        };
        _warningClearTimer.Start();
    }
    
    [JSInvokable]
    public void OnPositionJump(float fromX, float fromY, float toX, float toY, float distance)
    {
        Logger.LogWarning("[POSITION_JUMP] Player position jumped {Distance:F2} units from ({FromX:F2}, {FromY:F2}) to ({ToX:F2}, {ToY:F2})",
            distance, fromX, fromY, toX, toY);
    }
    
    [JSInvokable]
    public async Task OnKeyPress(string key)
    {
        switch (key.ToLower())
        {
            case "v":
                _isAutoMoveEnabled = !_isAutoMoveEnabled;
                Logger.LogInformation("Automove {State}", _isAutoMoveEnabled ? "enabled" : "disabled");
                await SaveSettings();
                StateHasChanged();
                break;
            case "t":
                _isTestMode = !_isTestMode;
                if (_autoMoveController != null)
                {
                    // Recreate controller with new test mode setting
                    var playerId = RpcGameClient.PlayerId;
                    if (!string.IsNullOrEmpty(playerId))
                    {
                        _autoMoveController = new AutoMoveController(Logger, playerId, _isTestMode);
                    }
                }
                Logger.LogInformation("Test mode {State}", _isTestMode ? "enabled" : "disabled");
                await SaveSettings();
                StateHasChanged();
                break;
        }
    }
    
    private async Task ToggleAutoMove()
    {
        _isAutoMoveEnabled = !_isAutoMoveEnabled;
        Logger.LogInformation("Automove {State}", _isAutoMoveEnabled ? "enabled" : "disabled");
        await SaveSettings();
        StateHasChanged();
    }
    
    private async Task ToggleAutoShoot()
    {
        _isAutoShootEnabled = !_isAutoShootEnabled;
        Logger.LogInformation("Auto shoot {State}", _isAutoShootEnabled ? "enabled" : "disabled");
        await SaveSettings();
        StateHasChanged();
    }
    
    private async Task ToggleTestMode()
    {
        _isTestMode = !_isTestMode;
        if (_autoMoveController != null)
        {
            // Recreate controller with new test mode setting
            var playerId = RpcGameClient.PlayerId;
            if (!string.IsNullOrEmpty(playerId))
            {
                _autoMoveController = new AutoMoveController(Logger, playerId, _isTestMode);
            }
        }
        Logger.LogInformation("Test mode {State}", _isTestMode ? "enabled" : "disabled");
        await SaveSettings();
        StateHasChanged();
    }

    private void UpdateAutoFeatures()
    {
        if (_lastWorldState == null || !RpcGameClient.IsConnected || _victoryPauseActive)
        {
            return;
        }
        
        var playerId = RpcGameClient.PlayerId;
        if (string.IsNullOrEmpty(playerId)) return;
        
        var player = _lastWorldState.Entities?.FirstOrDefault(e => e.EntityId == playerId);
        if (player == null) return;
        
        try
        {
            Vector2? moveDirection = null;
            Vector2? shootDirection = null;
            
            // Get movement decision from automove controller if enabled
            if (_isAutoMoveEnabled && _autoMoveController != null)
            {
                (moveDirection, shootDirection) = _autoMoveController.Update(
                    _lastWorldState,
                    _availableZones,
                    player.Position);
            }
            
            // Include auto shoot if enabled and not already shooting
            if (_isAutoShootEnabled && shootDirection == null)
            {
                // Find nearest target to shoot at (enemies have priority over factories)
                var targets = _lastWorldState.Entities?.Where(e => 
                    (e.Type == EntityType.Enemy || e.Type == EntityType.Factory || e.Type == EntityType.Asteroid) && 
                    e.State == EntityStateType.Active && 
                    e.Health > 0).ToList();
                    
                if (targets?.Any() == true)
                {
                    // Prioritize enemies over factories over asteroids
                    var prioritizedTarget = targets
                        .OrderBy(e => e.Type == EntityType.Enemy ? 0 : e.Type == EntityType.Factory ? 1 : 2)
                        .ThenBy(e => (player.Position - e.Position).Length())
                        .First();
                    shootDirection = (prioritizedTarget.Position - player.Position).Normalized();
                }
            }
            
            // Only send input if we have something to send
            if (moveDirection.HasValue || shootDirection.HasValue)
            {
                RpcGameClient.SendPlayerInputEx(moveDirection, shootDirection);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to update auto features");
        }
    }

    private void AddSystemMessage(string message)
    {
        _chatMessages.Add(new ChatDisplayMessage
        {
            Timestamp = DateTime.Now,
            Sender = "System",
            Text = message,
            Color = "#888888"
        });
        
        // Keep only last 100 messages
        if (_chatMessages.Count > 100)
        {
            _chatMessages.RemoveAt(0);
        }
    }
    
    private void AddChatMessage(string sender, string message, string color)
    {
        _chatMessages.Add(new ChatDisplayMessage
        {
            Timestamp = DateTime.Now,
            Sender = sender,
            Text = message,
            Color = color
        });
        
        // Keep only last 100 messages
        if (_chatMessages.Count > 100)
        {
            _chatMessages.RemoveAt(0);
        }
    }
    
    private string GetChatColor(string senderId)
    {
        // Generate a consistent color based on sender ID
        if (senderId == "System") return "#888888";
        if (senderId == RpcGameClient.PlayerId) return "#4CAF50"; // Green for self
        
        // Hash the sender ID to get a consistent color
        var hash = senderId.GetHashCode();
        var hue = Math.Abs(hash) % 360;
        return $"hsl({hue}, 70%, 60%)";
    }
    
    public async ValueTask DisposeAsync()
    {
        _updateTimer?.Dispose();
        _autoMoveTimer?.Dispose();
        _statsUpdateTimer?.Dispose();
        _warningClearTimer?.Dispose();
        
        if (_isInitialized)
        {
            RpcGameClient.WorldStateUpdated -= OnWorldStateUpdated;
            RpcGameClient.AvailableZonesUpdated -= OnAvailableZonesUpdated;
            RpcGameClient.PreEstablishedConnectionsUpdated -= OnPreEstablishedConnectionsUpdated;
            RpcGameClient.OneWayBoundaryStateChanged -= OnOneWayBoundaryStateChanged;
            
            try
            {
                await JS.InvokeVoidAsync("gamePhaser.destroy");
            }
            catch { }
        }
        
        _dotNetRef?.Dispose();
    }
    
    // Event handlers for RPC game client events
    private void OnVictoryPauseReceived(VictoryPauseMessage message)
    {
        InvokeAsync(async () =>
        {
            try
            {
                await JS.InvokeVoidAsync("gamePhaser.onVictoryPauseReceived", message);
            }
            catch { }
        });
    }
    
    private void OnGameOverReceived(GameOverMessage message)
    {
        InvokeAsync(() =>
        {
            try
            {
                // Display game over message in chat
                AddSystemMessage("=== GAME OVER ===");
                AddSystemMessage($"All enemies destroyed! Restarting in {message.RestartDelaySeconds} seconds...");
                
                if (message.PlayerScores.Any())
                {
                    AddSystemMessage("Final Scores (deaths):");
                    foreach (var score in message.PlayerScores.OrderBy(s => s.RespawnCount))
                    {
                        var isCurrentPlayer = score.PlayerId == RpcGameClient?.PlayerId;
                        var color = isCurrentPlayer ? "#4CAF50" : "#E0E0E0"; // Green for current player, white for others
                        AddChatMessage($"{score.PlayerName}: {score.RespawnCount} deaths", "Score", color);
                    }
                }
                
                AddSystemMessage("================");
                
                // Also try to call JavaScript method if it exists (graceful fallback)
                _ = JS.InvokeVoidAsync("gamePhaser.onGameOverReceived", message);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling game over message");
            }
        });
    }
    
    private void OnGameRestartedReceived()
    {
        InvokeAsync(() =>
        {
            try
            {
                // Display game restart message in chat
                AddSystemMessage("=== NEW GAME STARTED ===");
                AddSystemMessage("Good luck!");
                
                // Also try to call JavaScript method if it exists (graceful fallback)
                _ = JS.InvokeVoidAsync("gamePhaser.onGameRestartedReceived");
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error handling game restart message");
            }
        });
    }
    
    private void OnOneWayBoundaryStateChanged(GridSquare? previousZone, Vector2 boundaryNormal, bool isBlocked)
    {
        InvokeAsync(async () =>
        {
            try
            {
                // Convert to JavaScript-friendly format
                object? zoneObj = previousZone != null ? new { x = previousZone.X, y = previousZone.Y } : null;
                object normalObj = new { x = boundaryNormal.X, y = boundaryNormal.Y };
                
                await JS.InvokeVoidAsync("gamePhaser.updateOneWayBoundaryState", zoneObj, normalObj, isBlocked);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "Error updating one-way boundary state");
            }
        });
    }
    
    private void OnChatMessageReceived(ChatMessage message)
    {
        Logger.LogInformation("[CHAT] Received message from {Sender}: {Message}", message.SenderName, message.Message);
        AddChatMessage(message.Message, message.SenderName, "", message.IsSystemMessage);
        InvokeAsync(StateHasChanged);
    }
    
    // Helper methods
    private async Task SendChatMessage()
    {
        if (string.IsNullOrWhiteSpace(_chatInput)) return;
        
        var message = _chatInput.Trim();
        _chatInput = "";
        
        try
        {
            await RpcGameClient.SendChatMessage(message);
            Logger.LogInformation("[CHAT] Message sent successfully");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[CHAT] Failed to send message");
            AddSystemMessage("Failed to send message");
        }
    }
    
    private GridSquare? GetServerZone()
    {
        var serverId = RpcGameClient?.CurrentServerId;
        if (string.IsNullOrEmpty(serverId)) return null;
        
        // Extract zone from server ID (format: "action-server-x-y")
        var parts = serverId.Split('-');
        if (parts.Length >= 4 && int.TryParse(parts[2], out var x) && int.TryParse(parts[3], out var y))
        {
            return new GridSquare(x, y);
        }
        
        return null;
    }
    
    private async Task FetchServerZoneMappings()
    {
        try
        {
            // This is a placeholder - in the actual implementation, you would fetch from the server
            // For now, we're using the server ID parsing approach in GetServerZone()
            await Task.CompletedTask;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to fetch server zone mappings");
        }
    }
    
    private void AddChatMessage(string message, string senderName, string style = "", bool isSystem = false)
    {
        var color = GetChatColor(senderName, isSystem);
        
        var chatMessage = new ChatDisplayMessage
        {
            Sender = senderName,
            Text = message,
            Color = color,
            Timestamp = DateTime.Now
        };
        
        _chatMessages.Add(chatMessage);
        
        // Keep only last 50 messages
        while (_chatMessages.Count > 50)
        {
            _chatMessages.RemoveAt(0);
        }
        
        // Update Phaser UI
        InvokeAsync(async () =>
        {
            try
            {
                await JS.InvokeVoidAsync("gamePhaser.onChatMessageReceived", new
                {
                    text = message,
                    sender = senderName,
                    color = color,
                    timestamp = chatMessage.Timestamp.ToString("HH:mm:ss"),
                    isSystem = isSystem,
                    style = style
                });
            }
            catch { }
        });
    }
    
    private string GetChatColor(string senderName, bool isSystem)
    {
        if (isSystem) return "#FFD700"; // Gold for system messages
        if (senderName == RpcGameClient?.PlayerId) return "#00FF00"; // Green for own messages
        
        // Generate consistent color for other players
        var hash = senderName.GetHashCode();
        var hue = Math.Abs(hash % 360);
        return $"hsl({hue}, 70%, 60%)";
    }
    
    
    private async Task AddBot()
    {
        if (_isProcessing) return;
        
        _isProcessing = true;
        _desiredBotCount++;
        try
        {
            Logger.LogInformation("Adding new bot...");
            
            var siloUrl = Configuration["SiloUrl"] ?? "https://localhost:7071/";
            if (!siloUrl.EndsWith("/")) siloUrl += "/";
            
            using var httpClient = HttpClientFactory.CreateClient();
            var response = await httpClient.PostAsync($"{siloUrl}api/world/bots/add", null, _disposeCts.Token);
            if (response.IsSuccessStatusCode)
            {
                Logger.LogInformation("Successfully added new bot");
                AddSystemMessage("Bot added successfully");
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Logger.LogError("Failed to add bot: {Status} - {Error}", response.StatusCode, error);
                AddSystemMessage($"Failed to add bot: {response.StatusCode}");
                _desiredBotCount--; // Revert on failure
            }
        }
        catch (OperationCanceledException)
        {
            // Component is being disposed, ignore
            _desiredBotCount--; // Revert on failure
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error adding bot");
            AddSystemMessage("Error adding bot");
            _desiredBotCount--; // Revert on failure
        }
        finally
        {
            _isProcessing = false;
            StateHasChanged();
        }
    }
    
    private async Task RemoveBot()
    {
        if (_isProcessing || _desiredBotCount <= 0) return;
        
        _isProcessing = true;
        _desiredBotCount--;
        try
        {
            Logger.LogInformation("Removing bot...");
            
            var siloUrl = Configuration["SiloUrl"] ?? "https://localhost:7071/";
            if (!siloUrl.EndsWith("/")) siloUrl += "/";
            
            using var httpClient = HttpClientFactory.CreateClient();
            var response = await httpClient.PostAsync($"{siloUrl}api/world/bots/remove", null, _disposeCts.Token);
            if (response.IsSuccessStatusCode)
            {
                Logger.LogInformation("Successfully removed bot");
                AddSystemMessage("Bot removed successfully");
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Logger.LogError("Failed to remove bot: {Status} - {Error}", response.StatusCode, error);
                AddSystemMessage($"Failed to remove bot: {response.StatusCode}");
                _desiredBotCount++; // Revert on failure
            }
        }
        catch (OperationCanceledException)
        {
            // Component is being disposed, ignore
            _desiredBotCount++; // Revert on failure
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error removing bot");
            AddSystemMessage("Error removing bot");
            _desiredBotCount++; // Revert on failure
        }
        finally
        {
            _isProcessing = false;
            StateHasChanged();
        }
    }
    
    private async Task AddZone()
    {
        if (_isProcessing) return;
        
        _isProcessing = true;
        _desiredZoneCount++;
        try
        {
            Logger.LogInformation("Adding new zone...");
            
            var siloUrl = Configuration["SiloUrl"] ?? "https://localhost:7071/";
            if (!siloUrl.EndsWith("/")) siloUrl += "/";
            
            using var httpClient = HttpClientFactory.CreateClient();
            var response = await httpClient.PostAsync($"{siloUrl}api/world/action-servers/add", null, _disposeCts.Token);
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<Shooter.Shared.Models.ActionServerInfo>();
                Logger.LogInformation("Successfully added new zone at ({X}, {Y})", 
                    result?.AssignedSquare.X, result?.AssignedSquare.Y);
                AddSystemMessage($"Zone added at ({result?.AssignedSquare.X}, {result?.AssignedSquare.Y})");
            }
            else
            {
                var error = await response.Content.ReadAsStringAsync();
                Logger.LogError("Failed to add zone: {Status} - {Error}", response.StatusCode, error);
                
                // Handle specific status codes
                if ((int)response.StatusCode == 429)
                {
                    AddSystemMessage("Another zone addition is already in progress. Please wait and try again.");
                }
                else
                {
                    AddSystemMessage($"Failed to add zone: {response.StatusCode}");
                }
                
                _desiredZoneCount--; // Revert on failure
            }
        }
        catch (OperationCanceledException)
        {
            // Component is being disposed, ignore
            _desiredZoneCount--; // Revert on failure
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error adding zone");
            AddSystemMessage("Error adding zone");
            _desiredZoneCount--; // Revert on failure
        }
        finally
        {
            _isProcessing = false;
            StateHasChanged();
        }
    }
    
    private async Task RemoveZone()
    {
        if (_isProcessing || _desiredZoneCount <= 1) return; // Keep at least one zone
        
        _isProcessing = true;
        _desiredZoneCount--;
        try
        {
            // Get the last server (highest zone)
            var siloUrl = Configuration["SiloUrl"] ?? "https://localhost:7071/";
            if (!siloUrl.EndsWith("/")) siloUrl += "/";
            
            using var httpClient = HttpClientFactory.CreateClient();
            var serversResponse = await httpClient.GetFromJsonAsync<List<Shooter.Shared.Models.ActionServerInfo>>($"{siloUrl}api/world/action-servers", _disposeCts.Token);
            if (serversResponse != null && serversResponse.Any())
            {
                // Sort by zone coordinates to get the "last" zone
                var lastServer = serversResponse
                    .OrderByDescending(s => s.AssignedSquare.Y)
                    .ThenByDescending(s => s.AssignedSquare.X)
                    .First();
                
                Logger.LogInformation("Removing zone at ({X}, {Y})...", 
                    lastServer.AssignedSquare.X, lastServer.AssignedSquare.Y);
                
                var response = await httpClient.PostAsync(
                    $"{siloUrl}api/world/action-servers/{lastServer.ServerId}/remove", null);
                    
                if (response.IsSuccessStatusCode)
                {
                    Logger.LogInformation("Successfully removed zone");
                    AddSystemMessage($"Zone removed at ({lastServer.AssignedSquare.X}, {lastServer.AssignedSquare.Y})");
                }
                else
                {
                    var error = await response.Content.ReadAsStringAsync();
                    Logger.LogError("Failed to remove zone: {Status} - {Error}", response.StatusCode, error);
                    AddSystemMessage($"Failed to remove zone: {response.StatusCode}");
                    _desiredZoneCount++; // Revert on failure
                }
            }
            else
            {
                Logger.LogWarning("No zones available to remove");
                AddSystemMessage("No zones available to remove");
                _desiredZoneCount++; // Revert if no zones to remove
            }
        }
        catch (OperationCanceledException)
        {
            // Component is being disposed, ignore
            _desiredZoneCount++; // Revert on failure
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error removing zone");
            AddSystemMessage("Error removing zone");
            _desiredZoneCount++; // Revert on failure
        }
        finally
        {
            _isProcessing = false;
            StateHasChanged();
        }
    }
    
    public void Dispose()
    {
        _disposeCts.Cancel();
        
        _updateTimer?.Stop();
        _updateTimer?.Dispose();
        _autoMoveTimer?.Stop();
        _autoMoveTimer?.Dispose();
        _statsUpdateTimer?.Stop();
        _statsUpdateTimer?.Dispose();
        _warningClearTimer?.Stop();
        _warningClearTimer?.Dispose();
        _dotNetRef?.Dispose();
        
        // Unsubscribe from events
        RpcGameClient.WorldStateUpdated -= OnWorldStateUpdated;
        RpcGameClient.AvailableZonesUpdated -= OnAvailableZonesUpdated;
        RpcGameClient.PreEstablishedConnectionsUpdated -= OnPreEstablishedConnectionsUpdated;
        RpcGameClient.VictoryPauseReceived -= OnVictoryPauseReceived;
        RpcGameClient.GameOverReceived -= OnGameOverReceived;
        RpcGameClient.GameRestartedReceived -= OnGameRestartedReceived;
        RpcGameClient.OneWayBoundaryStateChanged -= OnOneWayBoundaryStateChanged;
        RpcGameClient.ChatMessageReceived -= OnChatMessageReceived;
        
        // Destroy Phaser game
        if (_isInitialized)
        {
            try
            {
                _ = JS.InvokeVoidAsync("gamePhaser.destroy");
            }
            catch { }
        }
        
        _disposeCts.Dispose();
    }
    
    // DTOs for zone stats
    private record WorldZoneStats(GridSquare Zone, int PlayerCount, int FactoryCount, int EnemyCount);
    
    private async Task LoadSettings()
    {
        try
        {
            var autoMoveValue = await JS.InvokeAsync<string?>("localStorage.getItem", "autoMove");
            if (bool.TryParse(autoMoveValue, out var autoMove))
            {
                _isAutoMoveEnabled = autoMove;
            }
            
            var autoShootValue = await JS.InvokeAsync<string?>("localStorage.getItem", "autoShoot");
            if (bool.TryParse(autoShootValue, out var autoShoot))
            {
                _isAutoShootEnabled = autoShoot;
            }
            
            var testModeValue = await JS.InvokeAsync<string?>("localStorage.getItem", "testMode");
            if (bool.TryParse(testModeValue, out var testMode))
            {
                _isTestMode = testMode;
            }
            
            Logger.LogInformation("Settings loaded: AutoMove={AutoMove}, AutoShoot={AutoShoot}, TestMode={TestMode}", 
                _isAutoMoveEnabled, _isAutoShootEnabled, _isTestMode);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load settings from localStorage");
        }
    }
    
    private async Task SaveSettings()
    {
        try
        {
            await JS.InvokeVoidAsync("localStorage.setItem", "autoMove", _isAutoMoveEnabled.ToString());
            await JS.InvokeVoidAsync("localStorage.setItem", "autoShoot", _isAutoShootEnabled.ToString());
            await JS.InvokeVoidAsync("localStorage.setItem", "testMode", _isTestMode.ToString());
            
            Logger.LogInformation("Settings saved: AutoMove={AutoMove}, AutoShoot={AutoShoot}, TestMode={TestMode}", 
                _isAutoMoveEnabled, _isAutoShootEnabled, _isTestMode);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to save settings to localStorage");
        }
    }
}

<style>
    .phaser-game-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 10px;
        height: 100%;
        background-color: #1a1a1a;
    }
    
    .phaser-viewport {
        flex-shrink: 0;
        width: 800px;
        height: 600px;
        margin: 0 auto;
        background-color: #000;
        border: 1px solid #333;
    }
    
    .chat-container {
        width: 800px;
        margin: 0 auto;
        background-color: #2a2a2a;
        border: 1px solid #444;
        border-radius: 4px;
        padding: 10px;
        max-height: 300px;
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .chat-history {
        flex: 1;
        overflow-y: auto;
        max-height: 220px;
        padding: 5px;
        background-color: #1a1a1a;
        border-radius: 4px;
        border: 1px solid #333;
        scroll-behavior: smooth;
    }
    
    .chat-message {
        margin-bottom: 4px;
        font-size: 12px;
        line-height: 1.2;
    }
    
    .chat-message .timestamp {
        color: #666;
        font-size: 11px;
    }
    
    .chat-message .sender {
        font-weight: bold;
        margin-left: 5px;
    }
    
    .chat-message .text {
        margin-left: 5px;
    }
    
    .chat-input {
        flex-shrink: 0;
    }
    
    .chat-input .input-group {
        display: flex;
        gap: 5px;
    }
    
    .chat-input .form-control {
        flex: 1;
        padding: 6px 10px;
        background-color: #333;
        border: 1px solid #555;
        color: white;
        border-radius: 4px;
        font-size: 14px;
    }
    
    .chat-input .form-control:focus {
        outline: none;
        border-color: #9C27B0;
    }
    
    .chat-input .btn {
        padding: 6px 12px;
        background-color: #9C27B0;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }
    
    .chat-input .btn:hover:not(:disabled) {
        background-color: #7B1FA2;
    }
    
    .chat-input .btn:disabled {
        background-color: #666;
        cursor: not-allowed;
    }
    
    .compact-controls {
        width: 800px;
        margin: 0 auto;
        display: flex;
        align-items: center;
        gap: 20px;
        padding: 10px;
        background-color: #2a2a2a;
        border: 1px solid #444;
        border-radius: 4px;
    }
    
    .game-info {
        width: 800px;
        margin: 0 auto;
        padding: 10px;
        background-color: #2a2a2a;
        border: 1px solid #444;
        border-radius: 4px;
        color: #e0e0e0;
        font-size: 14px;
    }
    
    .game-info .alert {
        margin-top: 10px;
        padding: 8px 12px;
        border-radius: 4px;
        background-color: #d32f2f;
        color: white;
        border: none;
    }
</style>