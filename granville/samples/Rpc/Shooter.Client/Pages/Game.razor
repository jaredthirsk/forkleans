@page "/game"
@using Shooter.Client.Common
@using Shooter.Client.Components
@using Shooter.Client.Services
@using Shooter.Shared.Models
@inject GranvilleRpcGameClientService RpcGameClient
@inject SignalRChatService SignalRChat
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject ILogger<Game> _logger
@inject HttpClient Http
@inject IConfiguration Configuration
@implements IDisposable

<PageTitle>Space Shooter</PageTitle>

<div class="game-container">
    @if (!_isConnected)
    {
        <div class="connection-form">
            <h2>Enter Game</h2>
            <input @bind="_playerName" @oninput="OnPlayerNameChanged" placeholder="Enter your name" />
            
            <div class="client-type-selection">
                <label for="clientType">Client Type:</label>
                <select id="clientType" @bind="_selectedClientType" @bind:after="OnClientTypeChanged" class="client-type-dropdown">
                    <option value="phaser">Phaser</option>
                    <option value="canvas">Canvas</option>
                </select>
            </div>
            
            <div class="auto-join-section">
                <label class="auto-join-checkbox">
                    <input type="checkbox" @bind="_autoJoinEnabled" @bind:after="OnAutoJoinChanged" />
                    <span>Auto-join in 5 seconds</span>
                </label>
                @if (_autoJoinEnabled && _countdownSeconds > 0)
                {
                    <div class="countdown">Auto-joining in @_countdownSeconds seconds...</div>
                }
                @if (_autoJoinRetrying)
                {
                    <div class="retry-status">
                        Retry #@_autoJoinRetryCount - @((int)(120 - (DateTime.UtcNow - _autoJoinRetryStartTime).TotalSeconds))s remaining
                    </div>
                }
            </div>
            
            <div class="join-button-section">
                <button @onclick="JoinGame" disabled="@_isConnecting" class="engine-btn join-btn">
                    @if (_isConnecting)
                    {
                        <span>Connecting...</span>
                    }
                    else if (_autoJoinRetrying)
                    {
                        <span>Retry #@_autoJoinRetryCount (Stop Auto-Join)</span>
                    }
                    else if (_autoJoinEnabled && _countdownSeconds > 0)
                    {
                        <span>Join Now (@_countdownSeconds...)</span>
                    }
                    else
                    {
                        <span>Join Game</span>
                    }
                </button>
            </div>
            
            @if (!string.IsNullOrEmpty(_errorMessage))
            {
                <div class="error">@_errorMessage</div>
            }
            
            <div class="connection-type">
                <small>Using: Granville RPC (UDP/LiteNetLib)</small>
            </div>
        </div>
    }
    else
    {
        <div class="game-layout">
            <div class="game-main">
                @if (_usePhaser)
                {
                    <GamePhaser />
                }
                else
                {
                    <GameCanvas Width="@GetCanvasWidth()" Height="@GetCanvasHeight()" 
                               WorldState="@_currentWorldState" 
                               PlayerId="@_playerId"
                               ServerId="@_currentServerId"
                               AvailableZones="@_availableZones"
                               OnMouseClick="HandleMouseClick"
                               OnMouseRightClick="HandleMouseRightClick"
                               OnMouseRelease="HandleMouseRelease" />
                }
                
                <StatusBar WarningMessage="@_debugInfo" />
                
                <div class="game-bottom-panel">
                    <GameChat Messages="@_chatMessages" OnSendMessage="HandleChatMessage" />
                </div>
            </div>
            <div class="game-sidebar">
                <Minimap
                    WorldState="@_currentWorldState"
                    AvailableZones="@_availableZones"
                    TotalSilos="@_totalSilos" />
                             
                <GameStats 
                    Fps="@_fps"
                    WorldState="@_currentWorldState"
                    ServerId="@_currentServerZone"
                    ServerFps="@_serverFps"
                    ActionServersConnected="@_serverZoneMap.Count"
                    CurrentSilo="@_currentSilo"
                    TotalSilos="@_totalSilos"
                    OnSwitchSilo="@HandleSwitchSilo" />
                
                <button class="disconnect-btn" @onclick="Disconnect">Disconnect</button>
                <button class="toggle-btn" @onclick="ToggleRenderer">Switch to @(_usePhaser ? "Canvas" : "Phaser")</button>
            </div>
        </div>
    }
</div>

<style>
    .game-container {
        padding: 20px;
        min-height: calc(100vh - 56px);
        background-color: #1a1a1a;
    }
    
    .connection-form {
        max-width: 400px;
        margin: 100px auto;
        padding: 30px;
        background-color: #2a2a2a;
        border-radius: 8px;
        text-align: center;
    }
    
    .connection-form h2 {
        color: #888;
        margin-bottom: 20px;
    }
    
    .connection-form input {
        width: 100%;
        padding: 10px;
        margin-bottom: 20px;
        background-color: #333;
        border: 1px solid #444;
        color: white;
        border-radius: 4px;
    }
    
    .client-type-selection {
        margin: 20px 0;
    }
    
    .client-type-selection label {
        display: block;
        margin-bottom: 8px;
        color: #888;
        font-size: 14px;
    }
    
    .client-type-dropdown {
        width: 100%;
        padding: 10px;
        background-color: #333;
        border: 1px solid #444;
        color: white;
        border-radius: 4px;
        font-size: 16px;
    }
    
    .auto-join-section {
        margin: 20px 0;
        text-align: center;
    }
    
    .auto-join-checkbox {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        cursor: pointer;
        color: #888;
        font-size: 14px;
    }
    
    .auto-join-checkbox input[type="checkbox"] {
        width: 16px;
        height: 16px;
        cursor: pointer;
    }
    
    .countdown {
        margin-top: 10px;
        color: #ff9800;
        font-weight: bold;
        font-size: 16px;
    }
    
    .retry-status {
        margin-top: 10px;
        color: #2196F3;
        font-weight: bold;
        font-size: 14px;
        text-align: center;
    }
    
    .join-button-section {
        margin-top: 20px;
    }
    
    .engine-btn {
        width: 100%;
        padding: 12px;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        transition: all 0.3s ease;
    }
    
    .join-btn {
        background-color: #9C27B0;
    }
    
    .join-btn:hover:not(:disabled) {
        background-color: #7B1FA2;
    }
    
    .engine-btn:disabled {
        background-color: #666;
        cursor: not-allowed;
    }
    
    .error {
        color: #ff4444;
        margin-top: 10px;
    }
    
    .connection-type {
        margin-top: 10px;
        color: #888;
    }
    
    .game-layout {
        display: flex;
        gap: 20px;
        max-width: 100%;
        overflow-x: auto;
    }
    
    .game-main {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 0; /* Allow shrinking */
        flex: 1;
    }
    
    .game-bottom-panel {
        width: 100%;
        max-width: 1200px;
        height: 200px;
        min-width: 320px;
    }
    
    .game-sidebar {
        display: flex;
        flex-direction: column;
        gap: 20px;
        flex-shrink: 0; /* Prevent sidebar from shrinking */
        min-width: 200px; /* Minimum sidebar width */
    }
    
    /* Responsive layout for Game.razor */
    @@media (max-width: 1400px) {
        .game-layout {
            gap: 15px;
        }
        
        .game-sidebar {
            min-width: 180px;
        }
    }
    
    @@media (max-width: 1200px) {
        .game-layout {
            gap: 10px;
        }
        
        .game-sidebar {
            min-width: 160px;
        }
    }
    
    @@media (max-width: 900px) {
        .game-layout {
            flex-direction: column;
            gap: 20px;
        }
        
        .game-sidebar {
            min-width: 0;
            width: 100%;
        }
        
        .game-bottom-panel {
            height: 150px; /* Smaller chat on mobile */
        }
    }
    
    @@media (max-width: 640px) {
        .game-layout {
            gap: 15px;
        }
        
        .game-bottom-panel {
            height: 120px; /* Even smaller chat on mobile */
        }
    }
    
    
    .disconnect-btn {
        padding: 10px 20px;
        background-color: #d32f2f;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
    }
    
    .toggle-btn {
        padding: 10px 20px;
        background-color: transparent;
        color: #2196F3;
        border: 2px solid #2196F3;
        border-radius: 4px;
        cursor: pointer;
        margin-top: 10px;
        transition: all 0.3s ease;
    }
    
    .toggle-btn:hover {
        background-color: #2196F3;
        color: white;
    }
</style>

@code {
    private string _playerName = "";
    private string _playerId = "";
    private string _currentServerId = "";
    private string _currentServerZone = "Unknown Zone";
    private bool _isConnected = false;
    private bool _isConnecting = false;
    private string _errorMessage = "";
    private WorldState? _currentWorldState;
    private int _fps = 0;
    private DateTime _lastFpsUpdate = DateTime.UtcNow;
    private int _frameCount = 0;
    private double _serverFps = 0;
    private DateTime _lastServerFpsUpdate = DateTime.MinValue;
    private Vector2 _currentMoveDirection = Vector2.Zero;
    private bool _currentIsShooting = false;
    private List<GridSquare> _availableZones = new();
    private Dictionary<string, GridSquare> _serverZoneMap = new();
    private float _currentSpeed = 1.0f;
    private Vector2 _shootDirection = Vector2.Zero;
    private bool _isMoving = false;
    private bool _usePhaser = true; // Default to Phaser renderer
    private string _selectedClientType = "phaser"; // Default to Phaser
    private bool _autoJoinEnabled = false;
    private int _countdownSeconds = 0;
    private System.Timers.Timer? _countdownTimer;
    private bool _autoJoinRetrying = false;
    private int _autoJoinRetryCount = 0;
    private DateTime _autoJoinRetryStartTime = DateTime.MinValue;
    private System.Timers.Timer? _autoJoinRetryTimer;
    private string? _debugInfo = null;
    private System.Timers.Timer? _serverMappingTimer;
    private bool _autoMove = false;
    private bool _autoShoot = false;
    private bool _testMode = true; // Enabled by default
    private CancellationTokenSource? _autoPilotCts;
    private CancellationTokenSource? _autoShootCts;
    private List<ChatMessage> _chatMessages = new();
    private Shooter.Shared.GrainInterfaces.SiloInfo? _currentSilo;
    private int _totalSilos = 0;
    
    protected override async void OnInitialized()
    {
        // Subscribe to RPC client events
        RpcGameClient.WorldStateUpdated += OnWorldStateUpdated;
        RpcGameClient.AvailableZonesUpdated += OnAvailableZonesUpdated;
        RpcGameClient.ServerChanged += OnServerChanged;
        RpcGameClient.ChatMessageReceived += OnChatMessageReceived;
        
        // Subscribe to SignalR chat events
        SignalRChat.ChatMessageReceived += OnSignalRChatMessageReceived;
        SignalRChat.SiloChanged += OnSiloChanged;
        SignalRChat.SilosUpdated += OnSilosUpdated;
        SignalRChat.ConnectionStatusChanged += OnSignalRConnectionChanged;
        
        // Initialize SignalR service
        await SignalRChat.InitializeAsync();
        
        // Set up timer to periodically refresh server zone mappings
        _serverMappingTimer = new System.Timers.Timer(5000); // Every 5 seconds
        _serverMappingTimer.Elapsed += async (s, e) => await RefreshServerMappings();
        _serverMappingTimer.Start();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Check localStorage for remembered player name after first render
            try
            {
                var rememberedName = await JS.InvokeAsync<string>("localStorage.getItem", "playerName");
                if (!string.IsNullOrEmpty(rememberedName))
                {
                    _playerName = rememberedName;
                    // Don't auto-connect, let user choose engine
                    StateHasChanged();
                }
                
                // Load auto-move and auto-shoot settings
                var autoMoveStr = await JS.InvokeAsync<string>("localStorage.getItem", "autoMove");
                var autoShootStr = await JS.InvokeAsync<string>("localStorage.getItem", "autoShoot");
                
                if (!string.IsNullOrEmpty(autoMoveStr) && bool.TryParse(autoMoveStr, out var autoMove))
                {
                    _autoMove = autoMove;
                }
                
                if (!string.IsNullOrEmpty(autoShootStr) && bool.TryParse(autoShootStr, out var autoShoot))
                {
                    _autoShoot = autoShoot;
                }
                
                // Load client type and auto-join settings
                var clientTypeStr = await JS.InvokeAsync<string>("localStorage.getItem", "clientType");
                if (!string.IsNullOrEmpty(clientTypeStr))
                {
                    _selectedClientType = clientTypeStr;
                    _usePhaser = clientTypeStr == "phaser";
                }
                
                var autoJoinStr = await JS.InvokeAsync<string>("localStorage.getItem", "autoJoin");
                if (!string.IsNullOrEmpty(autoJoinStr) && bool.TryParse(autoJoinStr, out var autoJoin))
                {
                    _autoJoinEnabled = autoJoin;
                }
                
                // Start auto-join countdown if enabled and player name is set
                if (_autoJoinEnabled && !string.IsNullOrEmpty(_playerName))
                {
                    StartAutoJoinCountdown();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error checking localStorage");
            }
        }
    }
    
    private async Task JoinGame()
    {
        if (string.IsNullOrWhiteSpace(_playerName))
        {
            _errorMessage = "Please enter your name";
            return;
        }
        
        // If retrying, stop the retry process
        if (_autoJoinRetrying)
        {
            StopAutoJoinRetry();
            _errorMessage = "Auto-join retry stopped";
            StateHasChanged();
            return;
        }
        
        // Stop countdown and retry timers if running
        StopAutoJoinCountdown();
        StopAutoJoinRetry();
        
        // Save client type preference
        await JS.InvokeVoidAsync("localStorage.setItem", "clientType", _selectedClientType);
        
        // Set _usePhaser based on selected client type
        _usePhaser = _selectedClientType == "phaser";
        
        await ConnectToGame(_usePhaser);
    }
    
    private async Task ConnectToGame(bool usePhaser)
    {
        _isConnecting = true;
        _errorMessage = "";
        _usePhaser = usePhaser;
        
        try
        {
            // Save player name to localStorage
            await JS.InvokeVoidAsync("localStorage.setItem", "playerName", _playerName);
            
            // Connect using Granville RPC
            var connected = await RpcGameClient.ConnectAsync(_playerName);
            if (connected)
            {
                _playerId = RpcGameClient.PlayerId ?? string.Empty;
                _currentServerId = RpcGameClient.CurrentServerId ?? "Unknown";
                _isConnected = true;
                
                // Stop auto-join retry on successful connection
                StopAutoJoinRetry();
                
                _logger.LogInformation("[GAME_CONNECT] RpcGameClient instance {InstanceId} - Connected with playerId: {PlayerId}", 
                    RpcGameClient.GetHashCode(), _playerId);
                
                // Connect to SignalR chat
                try
                {
                    await SignalRChat.ConnectAsync(_playerId, _playerName);
                    _logger.LogInformation("[GAME_CONNECT] Connected to SignalR chat");
                }
                catch (Exception chatEx)
                {
                    _logger.LogError(chatEx, "[GAME_CONNECT] Failed to connect to SignalR chat");
                    // Don't fail the whole connection if chat fails
                }
                
                // Fetch server zone mappings
                await FetchServerZoneMappings();
            }
            else
            {
                _errorMessage = "Failed to connect to game server";
                
                // Start auto-join retry if enabled
                if (_autoJoinEnabled && !_autoJoinRetrying)
                {
                    StartAutoJoinRetry();
                }
            }
        }
        catch (Exception ex)
        {
            _errorMessage = $"Connection error: {ex.Message}";
            
            // Start auto-join retry if enabled
            if (_autoJoinEnabled && !_autoJoinRetrying)
            {
                StartAutoJoinRetry();
            }
        }
        finally
        {
            _isConnecting = false;
        }
    }
    
    private void StartAutoJoinCountdown()
    {
        if (string.IsNullOrWhiteSpace(_playerName))
        {
            return; // Don't start countdown if no name
        }
        
        StopAutoJoinCountdown(); // Stop any existing countdown
        
        _countdownSeconds = 4; // 3.5 seconds + 0.5 for first display
        _countdownTimer = new System.Timers.Timer(1000); // 1 second interval
        _countdownTimer.Elapsed += async (sender, e) =>
        {
            _countdownSeconds--;
            await InvokeAsync(StateHasChanged);
            
            if (_countdownSeconds <= 0)
            {
                StopAutoJoinCountdown();
                await InvokeAsync(async () =>
                {
                    if (!_isConnecting && !_isConnected && !string.IsNullOrWhiteSpace(_playerName))
                    {
                        await JoinGame();
                    }
                });
            }
        };
        _countdownTimer.Start();
        StateHasChanged();
    }
    
    private void StopAutoJoinCountdown()
    {
        _countdownTimer?.Stop();
        _countdownTimer?.Dispose();
        _countdownTimer = null;
        _countdownSeconds = 0;
    }
    
    private void OnAutoJoinChanged()
    {
        // Save auto-join preference
        _ = JS.InvokeVoidAsync("localStorage.setItem", "autoJoin", _autoJoinEnabled.ToString());
        
        if (_autoJoinEnabled)
        {
            StartAutoJoinCountdown();
        }
        else
        {
            StopAutoJoinCountdown();
        }
    }
    
    private void OnClientTypeChanged()
    {
        // Save client type preference
        _ = JS.InvokeVoidAsync("localStorage.setItem", "clientType", _selectedClientType);
        _usePhaser = _selectedClientType == "phaser";
    }
    
    private async Task OnPlayerNameChanged(ChangeEventArgs e)
    {
        _playerName = e.Value?.ToString() ?? "";
        
        // Save player name to localStorage
        await JS.InvokeVoidAsync("localStorage.setItem", "playerName", _playerName);
        
        // Start auto-join countdown if enabled and name is not empty
        if (_autoJoinEnabled && !string.IsNullOrWhiteSpace(_playerName))
        {
            StartAutoJoinCountdown();
        }
        else if (_autoJoinEnabled && string.IsNullOrWhiteSpace(_playerName))
        {
            // Stop countdown if name is cleared
            StopAutoJoinCountdown();
        }
    }
    
    private async Task Disconnect()
    {
        await RpcGameClient.DisconnectAsync();
        _isConnected = false;
        
        // Clear remembered player name on disconnect
        await JS.InvokeVoidAsync("localStorage.removeItem", "playerName");
        
        Navigation.NavigateTo("/");
    }
    
    private async Task HandleMove(Vector2 direction)
    {
        _currentMoveDirection = direction * _currentSpeed * 100; // Scale movement speed appropriately
        _isMoving = direction.Length() > 0;
        await UpdatePlayerInput();
    }
    
    private async Task HandleShoot(bool isShooting)
    {
        _currentIsShooting = isShooting;
        await UpdatePlayerInput();
    }
    
    private async Task HandleSpeedChange(float speed)
    {
        _currentSpeed = speed;
        // Update movement with new speed
        if (_currentMoveDirection.Length() > 0)
        {
            _currentMoveDirection = _currentMoveDirection.Normalized() * _currentSpeed;
            await UpdatePlayerInput();
        }
    }
    
    private async void HandleAutoMoveChange(bool enabled)
    {
        _autoMove = enabled;
        
        // Save to localStorage
        try
        {
            await JS.InvokeVoidAsync("localStorage.setItem", "autoMove", enabled.ToString());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save autoMove setting");
        }
        
        if (_autoMove)
        {
            // Start auto-pilot movement
            _ = Task.Run(AutoPilotLoop);
        }
    }
    
    private async void HandleAutoShootChange(bool enabled)
    {
        _autoShoot = enabled;
        
        // Save to localStorage
        try
        {
            await JS.InvokeVoidAsync("localStorage.setItem", "autoShoot", enabled.ToString());
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to save autoShoot setting");
        }
        
        if (_autoShoot)
        {
            // Start auto-shoot loop
            _ = Task.Run(AutoShootLoop);
        }
    }
    
    private void HandleTestModeChange(bool enabled)
    {
        _testMode = enabled;
        if (_testMode)
        {
            // Initialize test bot behavior
            _logger.LogInformation("Test mode enabled");
            // TODO: Implement test bot logic
        }
        else
        {
            _logger.LogInformation("Test mode disabled");
        }
    }
    
    private async Task AutoPilotLoop()
    {
        _autoPilotCts?.Cancel();
        _autoPilotCts = new CancellationTokenSource();
        var token = _autoPilotCts.Token;
        
        try
        {
            while (_autoMove && !token.IsCancellationRequested)
            {
                if (_currentWorldState != null)
                {
                    // Find player entity
                    var player = _currentWorldState.Entities.FirstOrDefault(e => e.EntityId == _playerId);
                    if (player != null)
                    {
                        // Find nearest enemy or asteroid
                        var targets = _currentWorldState.Entities
                            .Where(e => (e.Type == EntityType.Enemy || e.Type == EntityType.Asteroid) && 
                                       e.Health > 0)
                            .OrderBy(e => player.Position.DistanceTo(e.Position))
                            .ToList();
                        
                        if (targets.Any())
                        {
                            var nearestTarget = targets.First();
                            var direction = (nearestTarget.Position - player.Position).Normalized();
                            
                            // Move towards the target with some distance management
                            var distance = player.Position.DistanceTo(nearestTarget.Position);
                            if (distance > 150f) // Keep some distance
                            {
                                await HandleMove(direction);
                            }
                            else if (distance < 80f) // Too close, back away
                            {
                                await HandleMove(direction * -1f);
                            }
                            else
                            {
                                // Strafe around the target
                                var strafeDir = new Vector2(-direction.Y, direction.X);
                                await HandleMove(strafeDir);
                            }
                        }
                        else
                        {
                            // No enemies in current zone, check for other zones with enemies
                            var zonesWithEnemies = await GetZonesWithEnemies();
                            if (zonesWithEnemies.Any())
                            {
                                // Move towards the nearest zone with enemies
                                var targetZone = zonesWithEnemies.OrderBy(z => 
                                    player.Position.DistanceTo(z.GetCenter())).First();
                                var direction = (targetZone.GetCenter() - player.Position).Normalized();
                                await HandleMove(direction);
                            }
                            else
                            {
                                // No enemies anywhere, move randomly
                                var randomAngle = Random.Shared.NextSingle() * MathF.PI * 2;
                                var randomDir = new Vector2(MathF.Cos(randomAngle), MathF.Sin(randomAngle));
                                await HandleMove(randomDir);
                            }
                        }
                    }
                }
                
                await Task.Delay(100, token); // Update every 100ms
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when cancelling
        }
        finally
        {
            // Stop moving when auto-pilot is disabled
            await HandleMove(Vector2.Zero);
        }
    }
    
    private async Task AutoShootLoop()
    {
        _autoShootCts?.Cancel();
        _autoShootCts = new CancellationTokenSource();
        var token = _autoShootCts.Token;
        
        try
        {
            while (_autoShoot && !token.IsCancellationRequested)
            {
                if (_currentWorldState != null)
                {
                    var player = _currentWorldState.Entities.FirstOrDefault(e => e.EntityId == _playerId);
                    if (player != null)
                    {
                        // Find nearest target with priority: Enemy > Factory > Asteroid
                        // Only target entities that are Active or Alerting (for Scouts)
                        var enemies = _currentWorldState.Entities
                            .Where(e => e.Type == EntityType.Enemy && 
                                   (e.State == EntityStateType.Active || e.State == EntityStateType.Alerting) && 
                                   e.Health > 0)
                            .OrderBy(e => player.Position.DistanceTo(e.Position))
                            .ToList();
                        
                        var factories = _currentWorldState.Entities
                            .Where(e => e.Type == EntityType.Factory && e.State == EntityStateType.Active && e.Health > 0)
                            .OrderBy(e => player.Position.DistanceTo(e.Position))
                            .ToList();
                        
                        var asteroids = _currentWorldState.Entities
                            .Where(e => e.Type == EntityType.Asteroid && e.State == EntityStateType.Active && e.Health > 0)
                            .OrderBy(e => player.Position.DistanceTo(e.Position))
                            .ToList();
                        
                        // Priority: Enemy (highest) > Factory (low) > Asteroid (lowest)
                        EntityState? target = null;
                        if (enemies.Any())
                        {
                            target = enemies.First();
                        }
                        else if (factories.Any())
                        {
                            // Target factories if no enemies are present
                            target = factories.First();
                        }
                        else if (asteroids.Any())
                        {
                            // Only target asteroids if no enemies or factories are present
                            target = asteroids.First();
                        }
                        
                        if (target != null)
                        {
                            var distance = player.Position.DistanceTo(target.Position);
                            if (distance < 300f) // Within shooting range
                            {
                                // Calculate shoot direction
                                var shootDir = (target.Position - player.Position).Normalized();
                                _shootDirection = shootDir;
                                
                                // Shoot burst
                                await HandleShoot(true);
                                await Task.Delay(200, token); // Shoot for 200ms
                                await HandleShoot(false);
                                await Task.Delay(300, token); // Wait 300ms before next burst
                            }
                        }
                    }
                }
                
                await Task.Delay(100, token); // Check every 100ms
            }
        }
        catch (OperationCanceledException)
        {
            // Expected when cancelling
        }
        finally
        {
            // Stop shooting when auto-shoot is disabled
            await HandleShoot(false);
        }
    }
    
    private Task<List<GridSquare>> GetZonesWithEnemies()
    {
        // TODO: This would need to query other zones for enemy counts
        // For now, just return empty list
        return Task.FromResult(new List<GridSquare>());
    }
    
    private void OnWorldStateUpdated(WorldState worldState)
    {
        _currentWorldState = worldState;
        
        // Update FPS counter
        _frameCount++;
        var now = DateTime.UtcNow;
        if ((now - _lastFpsUpdate).TotalSeconds >= 1)
        {
            _fps = _frameCount;
            _frameCount = 0;
            _lastFpsUpdate = now;
        }
        
        // Poll server FPS every second
        if ((now - _lastServerFpsUpdate).TotalSeconds >= 1)
        {
            _lastServerFpsUpdate = now;
            _ = Task.Run(async () =>
            {
                try
                {
                    if (RpcGameClient.IsConnected)
                    {
                        var fps = await RpcGameClient.GetServerFpsAsync();
                        _serverFps = fps;
                    }
                }
                catch (Exception ex)
                {
                    _logger.LogDebug("Failed to get server FPS: {Message}", ex.Message);
                }
            });
        }
        
        // Update server zone check
        UpdateServerZone();
        
        InvokeAsync(StateHasChanged);
    }
    
    private void OnAvailableZonesUpdated(List<GridSquare> availableZones)
    {
        _availableZones = availableZones;
        InvokeAsync(StateHasChanged);
    }
    
    private void OnServerChanged(string serverId)
    {
        _currentServerId = serverId;
        UpdateServerZone();
        InvokeAsync(async () =>
        {
            // Immediately fetch latest server mappings after zone transition
            await FetchServerZoneMappings();
            StateHasChanged();
        });
    }
    
    private void OnChatMessageReceived(ChatMessage message)
    {
        InvokeAsync(() =>
        {
            _chatMessages.Add(message);
            
            // Keep only last 100 messages
            if (_chatMessages.Count > 100)
            {
                _chatMessages.RemoveAt(0);
            }
            
            StateHasChanged();
        });
    }
    
    private async Task HandleChatMessage(string message)
    {
        try
        {
            // Use SignalR for chat instead of RPC
            await SignalRChat.SendMessageAsync(message);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to send chat message");
            // Add error message to chat
            var errorMessage = new ChatMessage(
                SenderId: "System",
                SenderName: "System",
                Message: $"Failed to send message: {ex.Message}",
                Timestamp: DateTime.UtcNow,
                IsSystemMessage: true
            );
            _chatMessages.Add(errorMessage);
            StateHasChanged();
        }
    }
    
    private void OnSignalRChatMessageReceived(ChatMessage message)
    {
        InvokeAsync(() =>
        {
            _chatMessages.Add(message);
            
            // Keep only last 100 messages
            if (_chatMessages.Count > 100)
            {
                _chatMessages.RemoveAt(0);
            }
            
            StateHasChanged();
        });
    }
    
    private void OnSiloChanged(Shooter.Shared.GrainInterfaces.SiloInfo silo)
    {
        InvokeAsync(() =>
        {
            _currentSilo = silo;
            StateHasChanged();
        });
    }
    
    private void OnSilosUpdated(List<Shooter.Shared.GrainInterfaces.SiloInfo> silos)
    {
        InvokeAsync(() =>
        {
            _totalSilos = silos.Count;
            StateHasChanged();
        });
    }
    
    private void OnSignalRConnectionChanged(string status)
    {
        InvokeAsync(() =>
        {
            _logger.LogInformation("[SIGNALR] Connection status: {Status}", status);
            StateHasChanged();
        });
    }
    
    private async Task HandleSwitchSilo()
    {
        try
        {
            await SignalRChat.SwitchToNextSiloAsync();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to switch silo");
        }
    }
    
    private void UpdateServerZone()
    {
        // Try to find the zone for this server
        if (_serverZoneMap.TryGetValue(_currentServerId, out var zone))
        {
            _currentServerZone = $"{zone.X}, {zone.Y}";
        }
        else
        {
            _currentServerZone = "Unknown Zone";
            _logger.LogDebug("No zone mapping found for server {ServerId}", _currentServerId);
        }
        
        // Check if player is in the correct zone
        if (_currentWorldState != null)
        {
            var player = _currentWorldState.Entities.FirstOrDefault(e => e.EntityId == _playerId);
            if (player != null)
            {
                var playerZone = GridSquare.FromPosition(player.Position);
                if (_serverZoneMap.TryGetValue(_currentServerId, out var serverZone) && playerZone != serverZone)
                {
                    var transitionDelay = DateTime.UtcNow.ToString("HH:mm:ss.fff");
                    _debugInfo = $"WARNING: Player in zone ({playerZone.X},{playerZone.Y}) but server handles ({serverZone.X},{serverZone.Y}) at {transitionDelay}";
                }
                else
                {
                    _debugInfo = null;
                }
            }
        }
    }
    
    private async Task HandleMouseClick((float x, float y) position)
    {
        if (!_isConnected || _currentWorldState == null) return;
        
        // Calculate direction from center to click position for shooting
        var centerX = 600; // Half of canvas width
        var centerY = 400; // Half of canvas height
        _shootDirection = new Vector2(position.x - centerX, position.y - centerY).Normalized();
        
        _currentIsShooting = true;
        await UpdatePlayerInput();
    }
    
    private async Task HandleMouseRightClick((float x, float y) position)
    {
        if (!_isConnected || _currentWorldState == null) return;
        
        // Calculate direction from center to click position for movement
        var centerX = 600; // Half of canvas width
        var centerY = 400; // Half of canvas height
        var direction = new Vector2(position.x - centerX, position.y - centerY).Normalized();
        
        _currentMoveDirection = direction * _currentSpeed * 40; // Scale movement speed to 40% of normal
        await UpdatePlayerInput();
    }
    
    private async Task HandleMouseRelease()
    {
        if (!_isConnected) return;
        
        _currentIsShooting = false;
        await UpdatePlayerInput();
    }
    
    private async Task UpdatePlayerInput()
    {
        if (!_isConnected) return;
        
        // Use the new extended input method that supports separate move and shoot directions
        Vector2? moveDir = _currentMoveDirection.Length() > 0 ? _currentMoveDirection : null;
        Vector2? shootDir = _currentIsShooting && _shootDirection.Length() > 0 ? _shootDirection : null;
        
        await RpcGameClient.SendPlayerInputEx(moveDir, shootDir);
    }
    
    private void ToggleRenderer()
    {
        _usePhaser = !_usePhaser;
        StateHasChanged();
    }
    
    private async Task FetchServerZoneMappings()
    {
        try
        {
            // Get all action servers from the silo
            var siloUrl = Configuration["SiloUrl"] ?? "https://localhost:7071/";
            if (!siloUrl.EndsWith("/")) siloUrl += "/";
            var response = await Http.GetFromJsonAsync<List<Shooter.Shared.Models.ActionServerInfo>>($"{siloUrl}api/world/action-servers");
            if (response != null)
            {
                _serverZoneMap.Clear();
                foreach (var server in response)
                {
                    _serverZoneMap[server.ServerId] = server.AssignedSquare;
                }
                UpdateServerZone();
                _logger.LogInformation("Fetched {Count} server zone mappings from {Url}", _serverZoneMap.Count, $"{siloUrl}api/world/action-servers");
                
                // Log the mappings for debugging
                foreach (var mapping in _serverZoneMap)
                {
                    _logger.LogInformation("Server {ServerId} -> Zone ({X}, {Y})", mapping.Key, mapping.Value.X, mapping.Value.Y);
                }
                
                // Log the current server's zone
                if (_serverZoneMap.TryGetValue(_currentServerId, out var currentZone))
                {
                    _logger.LogInformation("Current server {ServerId} is in zone ({X}, {Y})", _currentServerId, currentZone.X, currentZone.Y);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to fetch server zone mappings");
        }
    }
    
    private async Task RefreshServerMappings()
    {
        if (_isConnected)
        {
            await InvokeAsync(async () =>
            {
                await FetchServerZoneMappings();
            });
        }
    }
    
    private void StartAutoJoinRetry()
    {
        if (_autoJoinRetrying) return;
        
        _autoJoinRetrying = true;
        _autoJoinRetryCount = 0;
        _autoJoinRetryStartTime = DateTime.UtcNow;
        
        _logger.LogInformation("[AUTO_JOIN_RETRY] Starting auto-join retry process");
        
        // Start retry timer - retry every 10 seconds
        _autoJoinRetryTimer = new System.Timers.Timer(10000); // 10 seconds
        _autoJoinRetryTimer.Elapsed += async (sender, e) =>
        {
            var elapsedTime = DateTime.UtcNow - _autoJoinRetryStartTime;
            
            // Stop retrying after 2 minutes
            if (elapsedTime.TotalMinutes >= 2)
            {
                _logger.LogInformation("[AUTO_JOIN_RETRY] Giving up after 2 minutes, {RetryCount} attempts", _autoJoinRetryCount);
                StopAutoJoinRetry();
                await InvokeAsync(() =>
                {
                    _errorMessage = $"Auto-join failed after {_autoJoinRetryCount} attempts over 2 minutes";
                    StateHasChanged();
                });
                return;
            }
            
            // Don't retry if already connected or connecting
            if (_isConnected || _isConnecting)
            {
                StopAutoJoinRetry();
                return;
            }
            
            _autoJoinRetryCount++;
            _logger.LogInformation("[AUTO_JOIN_RETRY] Attempt #{RetryCount} (elapsed: {ElapsedMinutes:F1}m)", 
                _autoJoinRetryCount, elapsedTime.TotalMinutes);
            
            await InvokeAsync(async () =>
            {
                _errorMessage = $"Auto-join retry #{_autoJoinRetryCount} - {(int)(120 - elapsedTime.TotalSeconds)}s remaining";
                StateHasChanged();
                await ConnectToGame(_usePhaser);
            });
        };
        _autoJoinRetryTimer.Start();
        
        // Initial retry message
        _errorMessage = $"Auto-join retry #1 - 120s remaining";
        StateHasChanged();
    }
    
    private void StopAutoJoinRetry()
    {
        if (!_autoJoinRetrying) return;
        
        _autoJoinRetryTimer?.Stop();
        _autoJoinRetryTimer?.Dispose();
        _autoJoinRetryTimer = null;
        _autoJoinRetrying = false;
        _autoJoinRetryCount = 0;
        _autoJoinRetryStartTime = DateTime.MinValue;
        
        _logger.LogInformation("[AUTO_JOIN_RETRY] Stopped auto-join retry process");
    }
    
    private int GetCanvasWidth()
    {
        // Return responsive width that adapts to screen size
        // Default to 800px but can be smaller on narrow screens
        return 800;
    }
    
    private int GetCanvasHeight()
    {
        // Return responsive height that maintains aspect ratio
        // Default to 600px but can be smaller on narrow screens
        return 600;
    }
    
    public void Dispose()
    {
        _serverMappingTimer?.Stop();
        _serverMappingTimer?.Dispose();
        
        StopAutoJoinCountdown();
        StopAutoJoinRetry();
        
        // Unsubscribe from RPC events
        RpcGameClient.WorldStateUpdated -= OnWorldStateUpdated;
        RpcGameClient.AvailableZonesUpdated -= OnAvailableZonesUpdated;
        RpcGameClient.ServerChanged -= OnServerChanged;
        RpcGameClient.ChatMessageReceived -= OnChatMessageReceived;
        
        // Unsubscribe from SignalR events
        SignalRChat.ChatMessageReceived -= OnSignalRChatMessageReceived;
        SignalRChat.SiloChanged -= OnSiloChanged;
        SignalRChat.SilosUpdated -= OnSilosUpdated;
        SignalRChat.ConnectionStatusChanged -= OnSignalRConnectionChanged;
        
        // Disconnect SignalR
        _ = SignalRChat.DisconnectAsync();
    }
}