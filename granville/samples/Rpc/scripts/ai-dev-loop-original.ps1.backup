#!/usr/bin/env pwsh
<#
.SYNOPSIS
    AI-driven development loop for Shooter application debugging.
    
.DESCRIPTION
    This script enables Claude to monitor, analyze, and fix issues automatically:
    1. Starts Shooter components with full logging
    2. Monitors for errors/issues in real-time
    3. Pauses on errors and saves context for AI analysis
    4. Waits for AI to investigate and fix
    5. Restarts and continues testing
    
.PARAMETER MaxIterations
    Maximum number of fix attempts
    Default: 10
    
.PARAMETER RunDuration
    How long to run before considering it stable (seconds)
    Default: 60
    
.PARAMETER AutoFix
    Whether to automatically attempt fixes (requires AI interaction)
    Default: true
    
.EXAMPLE
    ./ai-dev-loop.ps1
    # Claude can then read the error files and fix issues
#>
param(
    [int]$MaxIterations = 10,
    [int]$RunDuration = 600,
    [bool]$AutoFix = $true
)

$ErrorActionPreference = "Stop"

# Session setup
$sessionId = Get-Date -Format "yyyyMMdd-HHmmss"
$workDir = "ai-dev-loop/$sessionId"
New-Item -ItemType Directory -Force -Path $workDir | Out-Null

# State file for AI to read
$stateFile = "$workDir/current-state.json"
$errorFile = "$workDir/last-error.txt"
$contextFile = "$workDir/error-context.log"
$instructionsFile = "$workDir/ai-instructions.txt"

# Statistics
$stats = @{
    Iteration = 0
    ErrorsFound = 0
    FixesApplied = 0
    SuccessfulRuns = 0
    StartTime = Get-Date
    LastError = $null
    State = "Starting"
}

function Write-State {
    param($State, $Message = "")
    
    $stats.State = $State
    $stats.LastUpdate = Get-Date
    $stats.Message = $Message
    
    $stats | ConvertTo-Json -Depth 3 | Out-File $stateFile
    
    $color = switch($State) {
        "Running" { "Green" }
        "Error" { "Red" }
        "Investigating" { "Yellow" }
        "Fixing" { "Cyan" }
        "Success" { "Green" }
        default { "White" }
    }
    
    Write-Host "[$State] $Message" -ForegroundColor $color
}

function Start-ShooterWithLogging {
    Write-State "Starting" "Launching Shooter via rl.sh (simplified approach)..."

    # Kill any existing processes first
    & "$PSScriptRoot/../scripts/kill-shooter-processes.sh"
    Start-Sleep -Seconds 2

    # Use the same simple approach as the successful bash version
    $currentDir = (Get-Location).Path
    $appHostDir = "$currentDir/granville/samples/Rpc/Shooter.AppHost"

    # Create log file paths but don't redirect I/O (avoid StreamWriter issues)
    $appHostLog = "$workDir/apphost-$($stats.Iteration).log"
    $appHostErrLog = "$workDir/apphost-$($stats.Iteration)-err.log"

    # Start rl.sh directly without I/O redirection (like the successful bash version)
    $appHostProc = Start-Process -FilePath "bash" `
        -ArgumentList "./rl.sh" `
        -WorkingDirectory $appHostDir `
        -PassThru

    # Create a simple process list for monitoring
    $processes = @(@{Name="AppHost"; Process=$appHostProc; LogFile=$appHostLog})

    # Wait for Aspire to start all services
    Write-Host "Waiting for Aspire AppHost to start all services..." -ForegroundColor Cyan
    Start-Sleep -Seconds 15

    Write-State "Running" "Aspire AppHost started via rl.sh. Monitoring for issues..."
    return $processes
}

function Monitor-ForErrors {
    param($Processes, $Duration)

    $startTime = Get-Date
    $errorFound = $false
    $errorDetails = @()
    $criticalPatterns = @(
        # Zone transition issues
        @{ Pattern = 'PROLONGED_MISMATCH'; Description = 'Zone mismatch lasting >5 seconds' },
        @{ Pattern = 'CHRONIC_MISMATCH'; Description = 'Repeated zone mismatches' },
        @{ Pattern = 'STUCK_TRANSITION'; Description = 'Zone transition stuck >10 seconds' },
        @{ Pattern = 'LOW_SUCCESS_RATE'; Description = 'Zone transition success rate <50%' },

        # Connection issues
        @{ Pattern = 'SSL connection could not be established'; Description = 'SSL certificate issue' },
        @{ Pattern = 'UntrustedRoot'; Description = 'Certificate trust problem' },
        @{ Pattern = 'Failed to connect to game'; Description = 'Game connection failure' },
        @{ Pattern = 'Bot SignalR connection closed'; Description = 'Bot connection lost' },
        @{ Pattern = 'Error registering player'; Description = 'Player registration failed' },
        @{ Pattern = 'RPC failed'; Description = 'RPC communication failure' },

        # Critical errors
        @{ Pattern = '\[Error\]'; Description = 'General error' },
        @{ Pattern = '\[HEALTH_MONITOR\].*ERROR'; Description = 'Health monitor error' },
        @{ Pattern = 'Exception:'; Description = 'Exception occurred' }
    )

    Write-Host "Monitoring for $Duration seconds..." -ForegroundColor Cyan
    Write-Host "Watching for critical patterns: zone mismatches, SSL errors, RPC failures" -ForegroundColor Gray

    # Log file locations
    $logFiles = @(
        "$PSScriptRoot/../logs/client.log",
        "$PSScriptRoot/../logs/client-console.log",
        "$PSScriptRoot/../logs/bot-0.log",
        "$PSScriptRoot/../logs/bot-0-console.log",
        "$PSScriptRoot/../logs/silo.log",
        "$PSScriptRoot/../logs/actionserver-*.log"
    )

    $checkInterval = 2
    $lastCheckTime = Get-Date

    while ((Get-Date) -lt $startTime.AddSeconds($Duration)) {
        # Check process health
        foreach ($proc in $Processes) {
            if ($proc.Process.HasExited) {
                $exitCode = $proc.Process.ExitCode
                if ($exitCode -ne 0) {
                    $errorFound = $true
                    $errorDetails += "Process crashed: $($proc.Name) with exit code $exitCode"
                }
            }
        }

        # Check log files for critical patterns
        foreach ($logPath in $logFiles) {
            $resolvedPaths = Get-Item $logPath -ErrorAction SilentlyContinue
            foreach ($path in $resolvedPaths) {
                if (Test-Path $path) {
                    # Get recent log entries (last 10 seconds)
                    $recentLogs = Get-Content $path -Tail 50 -ErrorAction SilentlyContinue

                    foreach ($pattern in $criticalPatterns) {
                        $matches = $recentLogs | Select-String -Pattern $pattern.Pattern -SimpleMatch:$false
                        if ($matches) {
                            $errorFound = $true
                            foreach ($match in $matches | Select-Object -First 3) {
                                $errorDetails += "[$($pattern.Description)] $($match.Line)"
                            }
                        }
                    }
                }
            }
        }

        if ($errorFound) {
            # Save comprehensive error details
            $errorReport = @"
=== ERROR DETECTION REPORT ===
Timestamp: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')

Critical Issues Found:
$($errorDetails | ForEach-Object { "- $_" } | Out-String)

Recommended Actions:
1. Check zone transition configuration
2. Verify SSL certificates are trusted
3. Ensure all services are responding
4. Check network connectivity
5. Review RPC client configuration
"@
            $errorReport | Out-File $errorFile

            # Also save recent logs for context
            $contextReport = @()
            foreach ($logPath in $logFiles) {
                $resolvedPaths = Get-Item $logPath -ErrorAction SilentlyContinue
                foreach ($path in $resolvedPaths) {
                    if (Test-Path $path) {
                        $contextReport += "`n=== Recent entries from $($path.Name) ==="
                        $contextReport += Get-Content $path -Tail 100 -ErrorAction SilentlyContinue
                    }
                }
            }
            $contextReport | Out-String | Out-File $contextFile

            break
        }

        # Show we're alive with more detail
        $uptimeSeconds = [int]((Get-Date) - $startTime).TotalSeconds
        Write-Host "[$uptimeSeconds s] " -NoNewline -ForegroundColor DarkGray
        Write-Host "." -NoNewline
        Start-Sleep -Seconds $checkInterval
    }

    Write-Host "" # New line after dots

    if ($errorFound) {
        $stats.ErrorsFound++
        $stats.LastError = $errorDetails -join "; "
        Write-State "Error" "Critical errors detected: $($errorDetails.Count) issues found"
        Write-Host "Error Details:" -ForegroundColor Red
        $errorDetails | Select-Object -First 5 | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }
        return $false
    }

    $stats.SuccessfulRuns++
    Write-State "Success" "No errors detected during $Duration second run"
    return $true
}

function Wait-ForAIFix {
    Write-State "Investigating" "Error captured. Ready for AI analysis."
    
    # Create instructions for AI
    $instructions = @"
=== AI DEBUGGING INSTRUCTIONS ===

An error has been detected in iteration $($stats.Iteration):
$($stats.LastError)

Files available for analysis:
- Error details: $errorFile
- Full context (last 200 lines): $contextFile
- All logs: $workDir/*.log

To fix this issue:
1. Read the error file: Read $errorFile
2. Read the context: Read $contextFile
3. Analyze the specific component logs if needed
4. Identify the root cause
5. Apply fixes to the source code
6. Signal completion by writing "FIXED" to: $workDir/fix-complete.txt

The script will automatically restart and test your fix.

Current statistics:
- Iterations: $($stats.Iteration)
- Errors found: $($stats.ErrorsFound)
- Fixes applied: $($stats.FixesApplied)
- Successful runs: $($stats.SuccessfulRuns)
"@
    
    $instructions | Out-File $instructionsFile
    
    Write-Host "`n$instructions" -ForegroundColor Yellow
    
    if ($AutoFix) {
        Write-Host "`nWaiting for AI to analyze and fix the issue..." -ForegroundColor Cyan
        Write-Host "AI should read: $errorFile" -ForegroundColor Gray
        Write-Host "When fixed, AI should write 'FIXED' to: $workDir/fix-complete.txt" -ForegroundColor Gray
        
        # Wait for AI to signal fix is complete
        $fixSignalFile = "$workDir/fix-complete.txt"
        $timeout = 300 # 5 minutes
        $waited = 0
        
        while (-not (Test-Path $fixSignalFile) -and $waited -lt $timeout) {
            Start-Sleep -Seconds 5
            $waited += 5
            
            if ($waited % 30 -eq 0) {
                Write-Host "Still waiting for fix... ($waited seconds)" -ForegroundColor Gray
            }
        }
        
        if (Test-Path $fixSignalFile) {
            $stats.FixesApplied++
            Write-State "Fixing" "Fix applied! Restarting to test..."
            Remove-Item $fixSignalFile
            return $true
        }
        else {
            Write-State "Investigating" "Timeout waiting for fix. Manual intervention needed."
            return $false
        }
    }
    else {
        Write-Host "`nPress Enter when you've fixed the issue..." -ForegroundColor Yellow
        Read-Host
        return $true
    }
}

function Stop-AllProcesses {
    # Use the same kill script as in the start function for consistency
    & "$PSScriptRoot/../scripts/kill-shooter-processes.sh"
    Start-Sleep -Seconds 2
}

# Main loop
Write-Host "=== AI Development Loop ===" -ForegroundColor Green
Write-Host "Session: $sessionId" -ForegroundColor Cyan
Write-Host "Working directory: $workDir" -ForegroundColor Cyan
Write-Host "Max iterations: $MaxIterations" -ForegroundColor Cyan
Write-Host "Run duration: $RunDuration seconds" -ForegroundColor Cyan
Write-Host ""

# Create initial detection info file for AI awareness
$detectionInfo = @"
=== AI DEV LOOP ACTIVE ===
Started: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')
Session: $sessionId
Monitoring for:
- Zone transition issues (PROLONGED_MISMATCH, CHRONIC_MISMATCH)
- SSL/Certificate errors
- RPC failures
- Bot connection issues
- Process crashes

This loop will:
1. Detect errors automatically
2. Stop affected services
3. Wait for AI fixes
4. Restart and verify fixes

Working directory: $workDir
"@
$detectionInfo | Out-File "$workDir/detection-active.txt"
Write-Host "Detection system active. Monitoring for critical issues..." -ForegroundColor Yellow

try {
    for ($i = 1; $i -le $MaxIterations; $i++) {
        $stats.Iteration = $i
        Write-Host "`n=== Iteration $i ===" -ForegroundColor Cyan
        
        # Start services
        $processes = Start-ShooterWithLogging
        
        # Monitor for errors
        $success = Monitor-ForErrors -Processes $processes -Duration $RunDuration
        
        # Stop all processes
        Stop-AllProcesses
        Start-Sleep -Seconds 2
        
        if ($success) {
            Write-State "Success" "Run completed successfully!"
            
            # Run longer test to confirm stability
            if ($i -lt $MaxIterations) {
                Write-Host "Running extended test (2x duration) to confirm stability..." -ForegroundColor Green
                $processes = Start-ShooterWithLogging
                $success = Monitor-ForErrors -Processes $processes -Duration ($RunDuration * 2)
                Stop-AllProcesses
                
                if ($success) {
                    Write-State "Success" "System is stable! No errors in extended test."
                    break
                }
            }
        }
        else {
            # Error found - wait for fix
            $fixed = Wait-ForAIFix
            
            if (-not $fixed) {
                Write-Host "Fix not applied. Stopping loop." -ForegroundColor Red
                break
            }
        }
    }
}
finally {
    Stop-AllProcesses
    
    # Final report
    $runtime = (Get-Date) - $stats.StartTime
    Write-Host "`n=== Final Report ===" -ForegroundColor Green
    Write-Host "Total runtime: $($runtime.ToString('hh\:mm\:ss'))" -ForegroundColor Cyan
    Write-Host "Iterations: $($stats.Iteration)" -ForegroundColor Cyan
    Write-Host "Errors found: $($stats.ErrorsFound)" -ForegroundColor $(if ($stats.ErrorsFound -gt 0) { "Yellow" } else { "Green" })
    Write-Host "Fixes applied: $($stats.FixesApplied)" -ForegroundColor Cyan
    Write-Host "Successful runs: $($stats.SuccessfulRuns)" -ForegroundColor Green
    Write-Host "Session data: $workDir" -ForegroundColor Gray
    
    # Save final state
    Write-State "Completed" "Dev loop completed"
}

Write-Host "`nDev loop session complete. Results in: $workDir" -ForegroundColor Cyan